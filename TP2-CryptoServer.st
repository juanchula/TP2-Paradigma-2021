Object subclass: #Application	instanceVariableNames: ''	classVariableNames: ''	package: 'TP2-CryptoServer'!!Application commentStamp: 'AlejandroFerrero 6/4/2021 17:52' prior: 0!Es la clase main que crea los objetos y lanza la ejecuci√≥n de la aplicaci√≥n.!Object subclass: #ClienteHTTP	instanceVariableNames: 'scheduler cliente_http_eth cliente_http_btc periodo valoresETH valoresBTC eventManager'	classVariableNames: ''	package: 'TP2-CryptoServer'!!ClienteHTTP commentStamp: 'AlejandroFerrero 6/4/2021 15:39' prior: 0!Clase que realiza requests HTTP (metodo GET) de forma peri√≥dica a la API CryptoMkt para obtener las cotizaciones actuales de una criptomoneda. !!ClienteHTTP methodsFor: 'accessing' stamp: 'AlejandroFerrero 6/5/2021 15:20'!valoresETH	^ valoresETH! !!ClienteHTTP methodsFor: 'accessing' stamp: 'AlejandroFerrero 6/5/2021 14:48'!cliente_http_btc: anObject	cliente_http_btc := anObject! !!ClienteHTTP methodsFor: 'accessing' stamp: 'AlejandroFerrero 6/4/2021 16:27'!periodo: anObject	periodo := anObject! !!ClienteHTTP methodsFor: 'accessing' stamp: 'AlejandroFerrero 6/4/2021 16:27'!scheduler: anObject	scheduler := anObject! !!ClienteHTTP methodsFor: 'accessing' stamp: 'AlejandroFerrero 6/5/2021 15:20'!valoresETH: anObject	valoresETH := anObject! !!ClienteHTTP methodsFor: 'accessing' stamp: 'AlejandroFerrero 6/5/2021 16:41'!eventManager	^ eventManager! !!ClienteHTTP methodsFor: 'accessing' stamp: 'AlejandroFerrero 6/4/2021 16:27'!cliente_http_eth	^ cliente_http_eth! !!ClienteHTTP methodsFor: 'accessing' stamp: 'AlejandroFerrero 6/5/2021 14:48'!cliente_http_btc	^ cliente_http_btc! !!ClienteHTTP methodsFor: 'accessing' stamp: 'AlejandroFerrero 6/4/2021 16:27'!cliente_http_eth: anObject	cliente_http_eth := anObject! !!ClienteHTTP methodsFor: 'accessing' stamp: 'AlejandroFerrero 6/4/2021 16:27'!periodo	^ periodo! !!ClienteHTTP methodsFor: 'accessing' stamp: 'AlejandroFerrero 6/5/2021 16:41'!eventManager: anObject	eventManager := anObject! !!ClienteHTTP methodsFor: 'accessing' stamp: 'AlejandroFerrero 6/5/2021 15:20'!valoresBTC	^ valoresBTC! !!ClienteHTTP methodsFor: 'accessing' stamp: 'AlejandroFerrero 6/4/2021 16:27'!scheduler	^ scheduler! !!ClienteHTTP methodsFor: 'accessing' stamp: 'AlejandroFerrero 6/5/2021 15:20'!valoresBTC: anObject	valoresBTC := anObject! !!ClienteHTTP methodsFor: 'scheduling' stamp: 'AlejandroFerrero 6/4/2021 16:31'!comenzarScheduler	self scheduler start! !!ClienteHTTP methodsFor: 'scheduling' stamp: 'AlejandroFerrero 6/5/2021 16:43'!setFuncionScheduler	"ejecuta una request http cada X seg periodicamente"		scheduler		do: [ | valBTC valETH |			valBTC := self doGetRequest: cliente_http_btc.			valETH := self doGetRequest: cliente_http_eth.			valoresBTC add: valBTC.			valoresETH add: valETH.			eventManager notify: valBTC.			eventManager notify: valETH.  ]		every: self periodo seconds. 	"30 seconds for example"! !!ClienteHTTP methodsFor: 'scheduling' stamp: 'AlejandroFerrero 6/4/2021 16:41'!detenerScheduler	self scheduler stop! !!ClienteHTTP methodsFor: 'initialization' stamp: 'AlejandroFerrero 6/5/2021 16:41'!initialize	"se crea un scheduler que ejecuta un GET cada X segundos"	scheduler := TaskScheduler new.	"cliente http para los GET de la cripto Etherium"	cliente_http_eth := ZnClient new		url: 'https://api.cryptomkt.com/v1/ticker?market=ETHARS'.			"cliente http para los GET de la cripto Bitcoin"	cliente_http_btc := ZnClient new		url: 'https://api.cryptomkt.com/v1/ticker?market=BTCARS'.			"periodo en el cual se realizan los GET a la API CryptoMkt"	periodo := 30.		"Array que contiene los valores consultados de la cripto Bitcoin"	valoresBTC := OrderedCollection new.		"Array que contiene los valores consultados de la cripto Etherium"	valoresETH := OrderedCollection new.		"Maneja la lista de objetos suscritos a la espera de un evento."	eventManager := GestorDeEventos new.	! !!ClienteHTTP methodsFor: 'api' stamp: 'AlejandroFerrero 6/4/2021 15:48'!doGetRequest: aClientHTTP	| respuesta json json_dict dict |	"response de la consulta http"	respuesta := aClientHTTP		get;		response.	"string del body de la response"	json := respuesta entity string.	"se convierte el string devuelto en un diccionario con todos los valores de la cripto"	json_dict := NeoJSONReader fromString: json.	dict := json_dict at: 'data' at: 1.	^ dict! !Object subclass: #GestorDeEventos	instanceVariableNames: 'listeners'	classVariableNames: ''	package: 'TP2-CryptoServer'!!GestorDeEventos commentStamp: 'AlejandroFerrero 6/4/2021 17:55' prior: 0!Tambi√©n llamado EventManager, es el encargado de mantener la lista de suscriptores y de notificarlos cuando haya ocurrido un evento para los que est√©n esperando.!!GestorDeEventos methodsFor: 'observer' stamp: 'AlejandroFerrero 6/5/2021 16:39'!notify: aData	"Notifica a todos los objetos que est√°n suscritos a un evento. aData es el dato enviado (valor de la cotizaci√≥n en el momento) a los objetos."	"1 to: listeners size do:[:indice | (listeners at: indice) update: aData]."	listeners do: [ :item | item update: aData ]! !!GestorDeEventos methodsFor: 'observer' stamp: 'AlejandroFerrero 6/5/2021 16:22'!unsubscribe: aListener	"Elimina de la lista de suscritos a un elemento"	| indice |	indice := listeners indexOf: aListener.	indice > 0		ifTrue: [ listeners removeAt: indice ]! !!GestorDeEventos methodsFor: 'observer' stamp: 'AlejandroFerrero 6/5/2021 16:09'!subscribe: aListener	"Agrega un listener a la lista de suscritos"	listeners add: aListener! !!GestorDeEventos methodsFor: 'initialization' stamp: 'AlejandroFerrero 6/5/2021 16:06'!initialize	"Crea una lista de listeres"	listeners := OrderedCollection new! !Object subclass: #WebSocketClient	instanceVariableNames: 'url webSocket'	classVariableNames: ''	package: 'TP2-CryptoServer'!!WebSocketClient commentStamp: 'AlejandroFerrero 6/4/2021 16:58' prior: 0!Web Socket del lado cliente.!!WebSocketClient methodsFor: 'initialization' stamp: 'AlejandroFerrero 6/4/2021 17:41'!initialize	url := 'ws://localhost:1701'.	webSocket := ZnWebSocket to: url.! !Object subclass: #WebSocketServer	instanceVariableNames: 'nroPuerto data'	classVariableNames: ''	package: 'TP2-CryptoServer'!!WebSocketServer commentStamp: 'AlejandroFerrero 6/4/2021 16:58' prior: 0!Web Socket del lado del servidor.!!WebSocketServer methodsFor: 'accessing' stamp: 'JuanIgnacioFernandez 6/5/2021 18:30'!data	^ data! !!WebSocketServer methodsFor: 'accessing' stamp: 'JuanIgnacioFernandez 6/5/2021 18:16'!data: anObject	data := anObject! !!WebSocketServer methodsFor: 'initialization' stamp: 'JuanIgnacioFernandez 6/5/2021 20:46'!generarHtml: dict	! !!WebSocketServer methodsFor: 'initialization' stamp: 'JuanIgnacioFernandez 6/5/2021 22:29'!initialize		data := '<html>   <head>            <script type = "text/JavaScript">         <!!--            function AutoRefresh( t ) {               setTimeout("location.reload(true);", t);            }         //-->      </script>         </head>      <body onload = "JavaScript:AutoRefresh(1000);">      <p>This page will refresh every 1 seconds.</p>   </body>   </html>'.! !!WebSocketServer methodsFor: 'initialization' stamp: 'JuanIgnacioFernandez 6/5/2021 18:14'!uptade: aDatadata := aData! !!WebSocketServer methodsFor: 'initialization' stamp: 'Anonymous 6/5/2021 18:07'!value: request   ^ self handleRequest: request! !!WebSocketServer methodsFor: 'initialization' stamp: 'JuanIgnacioFernandez 6/5/2021 21:02'!handleRequest: request   request uri path = 'crypto-server'      ifFalse: [ ^ ZnResponse notFound: request uri ].   ^ ZnResponse ok: (ZnEntity text: data).   "^ ZnResponse ok: (ZnEntity dictionary: data)"! !