Object subclass: #Application	instanceVariableNames: 'server cliente_http'	classVariableNames: ''	package: 'TP2-CryptoServer'!!Application commentStamp: 'AlejandroFerrero 6/11/2021 16:33' prior: 0!Es la clase main que crea los objetos y lanza la ejecucion de la aplicacion.!!Application methodsFor: 'accessing' stamp: 'AlejandroFerrero 6/11/2021 16:37'!server	^ server! !!Application methodsFor: 'accessing' stamp: 'JuanIgnacioFernandez 6/15/2021 23:32'!main 	"Metodo principal que se ejecuta justo despues del initialize, es el que define el funcionamiento de la app."	| gestorEventos |	server startServidor .	cliente_http := ClienteHTTP new.		gestorEventos := cliente_http eventManager.	gestorEventos subscribe: server webSocket.		cliente_http setFuncionScheduler .	"ret := cliente_http doGetRequest: (cliente_http cliente_http_eth)."	cliente_http comenzarScheduler .	"30 second asDelay wait.	cliente_http detenerScheduler ."! !!Application methodsFor: 'accessing' stamp: 'AlejandroFerrero 6/11/2021 16:37'!server: anObject	server := anObject! !!Application methodsFor: 'initialization' stamp: 'AlejandroFerrero 6/15/2021 21:02'!initialize 	server := ServidorHTTP uniqueInstance.	cliente_http := ClienteHTTP new.! !Object subclass: #ClienteHTTP	instanceVariableNames: 'cliente_http_eth cliente_http_btc periodo valoresETH valoresBTC eventManager'	classVariableNames: ''	package: 'TP2-CryptoServer'!!ClienteHTTP commentStamp: 'AlejandroFerrero 6/4/2021 15:39' prior: 0!Clase que realiza requests HTTP (metodo GET) de forma peri√≥dica a la API CryptoMkt para obtener las cotizaciones actuales de una criptomoneda. !!ClienteHTTP methodsFor: 'accessing' stamp: 'AlejandroFerrero 6/5/2021 15:20'!valoresETH	^ valoresETH! !!ClienteHTTP methodsFor: 'accessing' stamp: 'AlejandroFerrero 6/5/2021 14:48'!cliente_http_btc: anObject	cliente_http_btc := anObject! !!ClienteHTTP methodsFor: 'accessing' stamp: 'AlejandroFerrero 6/4/2021 16:27'!periodo: anObject	periodo := anObject! !!ClienteHTTP methodsFor: 'accessing' stamp: 'AlejandroFerrero 6/5/2021 15:20'!valoresETH: anObject	valoresETH := anObject! !!ClienteHTTP methodsFor: 'accessing' stamp: 'AlejandroFerrero 6/5/2021 16:41'!eventManager	^ eventManager! !!ClienteHTTP methodsFor: 'accessing' stamp: 'AlejandroFerrero 6/4/2021 16:27'!cliente_http_eth	^ cliente_http_eth! !!ClienteHTTP methodsFor: 'accessing' stamp: 'AlejandroFerrero 6/5/2021 14:48'!cliente_http_btc	^ cliente_http_btc! !!ClienteHTTP methodsFor: 'accessing' stamp: 'AlejandroFerrero 6/4/2021 16:27'!cliente_http_eth: anObject	cliente_http_eth := anObject! !!ClienteHTTP methodsFor: 'accessing' stamp: 'AlejandroFerrero 6/4/2021 16:27'!periodo	^ periodo! !!ClienteHTTP methodsFor: 'accessing' stamp: 'AlejandroFerrero 6/5/2021 16:41'!eventManager: anObject	eventManager := anObject! !!ClienteHTTP methodsFor: 'accessing' stamp: 'AlejandroFerrero 6/5/2021 15:20'!valoresBTC	^ valoresBTC! !!ClienteHTTP methodsFor: 'accessing' stamp: 'AlejandroFerrero 6/5/2021 15:20'!valoresBTC: anObject	valoresBTC := anObject! !!ClienteHTTP methodsFor: 'api' stamp: 'AlejandroFerrero 6/11/2021 13:16'!doGetRequest: aClientHTTP	| respuesta json json_dict dict lista diccionario |	"response de la consulta http"	respuesta := aClientHTTP		get;		response.	"string del body de la response"	json := respuesta entity string.	"se convierte el string devuelto en un diccionario con todos los valores de la cripto"	json_dict := NeoJSONReader fromString: json.	lista := json_dict at: 'data'.	diccionario  :=  lista at: 1 .	"dict := NeoJSONWriter toString: diccionario."	dict := diccionario .	"dict := (json_dict at: 'data') at: 1. "	"se retorna el diccionario"	^ dict! !!ClienteHTTP methodsFor: 'scheduling' stamp: 'JuanIgnacioFernandez 6/15/2021 23:30'!detenerScheduler	ClienteHTTP scheduler stop! !!ClienteHTTP methodsFor: 'scheduling' stamp: 'JuanIgnacioFernandez 6/15/2021 23:29'!setFuncionScheduler	"ejecuta una request http cada X seg periodicamente"		ClienteHTTP scheduler		do: [ | valBTC valETH valores jsonCriptos |			valores := Dictionary new.			valBTC := self doGetRequest: cliente_http_btc.			valETH := self doGetRequest: cliente_http_eth.			valoresBTC add: valBTC.			valoresETH add: valETH.			valores at: 'bitcoin' put: valBTC.			valores at: 'ethereum' put: valETH.			eventManager notify: valores.]		every: self periodo seconds. 	"30 seconds for example"! !!ClienteHTTP methodsFor: 'scheduling' stamp: 'JuanIgnacioFernandez 6/15/2021 23:30'!comenzarScheduler	ClienteHTTP  scheduler start! !!ClienteHTTP methodsFor: 'initialization' stamp: 'JuanIgnacioFernandez 6/16/2021 00:01'!initialize	"se crea un scheduler que ejecuta un GET cada X segundos"	ClienteHTTP scheduler: TaskScheduler new.	"cliente http para los GET de la cripto Etherium"	cliente_http_eth := ZnClient new		url: 'https://api.cryptomkt.com/v1/ticker?market=ETHARS'.			"cliente http para los GET de la cripto Bitcoin"	cliente_http_btc := ZnClient new		url: 'https://api.cryptomkt.com/v1/ticker?market=BTCARS'.			"periodo en el cual se realizan los GET a la API CryptoMkt"	periodo := 10.		"Array que contiene los valores consultados de la cripto Bitcoin"	valoresBTC := OrderedCollection new.		"Array que contiene los valores consultados de la cripto Etherium"	valoresETH := OrderedCollection new.		"Maneja la lista de objetos suscritos a la espera de un evento."	eventManager := GestorDeEventos new.	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ClienteHTTP class	instanceVariableNames: 'scheduler'!!ClienteHTTP class methodsFor: 'accessing' stamp: 'JuanIgnacioFernandez 6/15/2021 23:27'!scheduler: anObject	scheduler := anObject! !!ClienteHTTP class methodsFor: 'accessing' stamp: 'JuanIgnacioFernandez 6/15/2021 23:27'!scheduler	^ scheduler! !Object subclass: #GestorDeEventos	instanceVariableNames: 'listeners'	classVariableNames: ''	package: 'TP2-CryptoServer'!!GestorDeEventos commentStamp: 'AlejandroFerrero 6/4/2021 17:55' prior: 0!Tambi√©n llamado EventManager, es el encargado de mantener la lista de suscriptores y de notificarlos cuando haya ocurrido un evento para los que est√©n esperando.!!GestorDeEventos methodsFor: 'accessing' stamp: 'AlejandroFerrero 6/10/2021 22:59'!listeners	^ listeners! !!GestorDeEventos methodsFor: 'accessing' stamp: 'AlejandroFerrero 6/10/2021 22:59'!listeners: anObject	listeners := anObject! !!GestorDeEventos methodsFor: 'initialization' stamp: 'AlejandroFerrero 6/11/2021 13:04'!initialize	"Crea una lista de listeres que son los objetos a ser notificados"	listeners := OrderedCollection new! !!GestorDeEventos methodsFor: 'observer' stamp: 'AlejandroFerrero 6/6/2021 23:10'!notify: aData	"Notifica a todos los objetos que estan suscritos a un evento. aData es el dato enviado (valor de la cotizacian en el momento) a los objetos."	"1 to: listeners size do:[:indice | (listeners at: indice) update: aData]."	listeners do: [ :item | item update: aData ].! !!GestorDeEventos methodsFor: 'observer' stamp: 'AlejandroFerrero 6/5/2021 16:22'!unsubscribe: aListener	"Elimina de la lista de suscritos a un elemento"	| indice |	indice := listeners indexOf: aListener.	indice > 0		ifTrue: [ listeners removeAt: indice ]! !!GestorDeEventos methodsFor: 'observer' stamp: 'AlejandroFerrero 6/5/2021 16:09'!subscribe: aListener	"Agrega un listener a la lista de suscritos"	listeners add: aListener! !Object subclass: #Indicador	instanceVariableNames: ''	classVariableNames: ''	package: 'TP2-CryptoServer'!!Indicador commentStamp: 'AlejandroFerrero 6/11/2021 17:37' prior: 0!Interface que agrupa distintas estrategias de compra venta.!!Indicador methodsFor: 'as yet unclassified' stamp: 'AlejandroFerrero 6/11/2021 17:51'!calcularMetrica: valoresMercado	""	self subclassResponsibility.! !Indicador subclass: #IndicadorMomentum	instanceVariableNames: ''	classVariableNames: ''	package: 'TP2-CryptoServer'!!IndicadorMomentum commentStamp: 'AlejandroFerrero 6/11/2021 17:44' prior: 0!Estrategia que calcula el Momentum de una criptomoneda a partir de sus valores de mercado.!!IndicadorMomentum methodsFor: 'as yet unclassified' stamp: 'JuanIgnacioFernandez 6/16/2021 00:10'!calcularMetrica: valoresMercado 	|bid low high dif fibonacci raizA raizB|	bid := (valoresMercado at: 'bid') asNumber asFloat.	low := (valoresMercado at: 'low') asNumber asFloat.	high := (valoresMercado at: 'high') asNumber asFloat.	dif := (high - low)/2.	" n is Fibinacci if one of 5*n*n + 4 or 5*n*n - 4 or both     is a perferct square"raizA := (((5*bid*bid) + 4) sqrt) round:1.raizB := (((5*bid*bid) - 4) sqrt) round:1.fibonacci := ((raizA*raizA) = ((5*bid*bid) + 4)) | ((raizB*raizB) = ((5*bid*bid) - 4)) .		fibonacci ifTrue: [ ^'comprar'. ].	(bid - dif > low) ifTrue: [ ^''. ].	^'vender'.! !Indicador subclass: #IndicadorRSI	instanceVariableNames: ''	classVariableNames: ''	package: 'TP2-CryptoServer'!!IndicadorRSI commentStamp: 'AlejandroFerrero 6/11/2021 17:40' prior: 0!Estrategia que calcula el RSI de una criptomoneda a partir de sus valores de mercado.!!IndicadorRSI methodsFor: 'as yet unclassified' stamp: 'JuanIgnacioFernandez 6/16/2021 00:07'!calcularMetrica: valoresMercado 	|bid low high dif|	bid := (valoresMercado at: 'bid') asNumber asFloat.	low := (valoresMercado at: 'low') asNumber asFloat.	high := (valoresMercado at: 'high') asNumber asFloat.	dif := (high - low)/2.	((bid+dif) > high) ifTrue: [ ^'vender'. ].	(bid-(dif*3) > low) ifTrue: [ ^'vender'. ].	^'vender'.! !Object subclass: #ServidorHTTP	instanceVariableNames: 'ipAddr nroPuerto webSocket html'	classVariableNames: ''	package: 'TP2-CryptoServer'!!ServidorHTTP commentStamp: 'AlejandroFerrero 6/6/2021 20:06' prior: 0!Servidor HTTP que muestra las cotizaciones actualizadas de las criptomonedas. Utiliza un web socket para actualizar los valores dinámicamente.!!ServidorHTTP methodsFor: 'initialization' stamp: 'AlejandroFerrero 6/15/2021 21:15'!initialize		ipAddr := #[127 0 0 1].		nroPuerto := 1701.		webSocket := WebSocketServer new.		html := '<!!DOCTYPE html><html lang="es"><head>  <meta charset="utf-8"/>  <meta name="description" content="Aquí puedes encontrar las últimas cotizaciones de las criptomonedas más populares del mercado, junto a algunos consejos de compra.">  <title>Cotizaciones Crypto Server</title></head><body>  <h1><u>Cotizaciones <i>Crypto Server</i> en tiempo real</u></h1>  <div id="tituloBTC" style="padding:10px; width: 99%; line-height:0.1;">    <h2>Bitcoin (BTC)</h2>  </div>  <ul>    <li><b>Timestamp:</b></li><p id="timestamp_btc"></p>    <li><b>Market:</b></li><p id="market_btc"></p>    <li><b>Bid:</b></li><p id="bid_btc"></p>    <li><b>Ask:</b></li><p id="ask_btc"></p>    <li><b>Last price:</b></li><p id="last_price_btc"></p>    <li><b>Low:</b></li><p id="low_btc"></p>    <li><b>High:</b></li><p id="high_btc"></p>    <li><b>Volume:</b></li><p id="volume_btc"></p>  </ul>  <select name="indicadorBTC" id="indicadorBTC" onchange="selectEstrategia(this)">    <option value="rsi-btc">RSI</option>    <option value="momentum-btc">Momentum</option>  </select>  <div id="tituloETH" style="padding:10px; width: 99%; line-height:0.1;">    <h2>Ether (ETH)</h2>  </div>  <ul>    <li><b>Timestamp:</b></li><p id="timestamp_eth"></p>    <li><b>Market:</b></li><p id="market_eth"></p>    <li><b>Bid:</b></li><p id="bid_eth"></p>    <li><b>Ask:</b></li><p id="ask_eth"></p>    <li><b>Last price:</b></li><p id="last_price_eth"></p>    <li><b>Low:</b></li><p id="low_eth"></p>    <li><b>High:</b></li><p id="high_eth"></p>    <li><b>Volume:</b></li><p id="volume_eth"></p>  </ul>  <select name="indicadorETH" id="indicadorETH" onchange="selectEstrategia(this)">    <option value="rsi-eth">RSI</option>    <option value="momentum-eth">Momentum</option>  </select>  <script language="javascript" type="text/javascript">      const ROJO = "#FC3232";      const VERDE = "#5BCA57";      const GRIS = "#D6D6D6";      var wsUri = "ws://" + location.host + "/ws-crypto-server";      var exampleSocket = new WebSocket(wsUri);      var ret;      var metricas = {"btc" : "rsi", "eth" : "rsi"};            exampleSocket.onmessage = function(event) {        exampleSocket.send(JSON.stringify(metricas));        console.log(event.data);        ret = event.data;        if(ret !!= "{}"){          var jsonRet = JSON.parse(ret);          var accion;          //para Bitcoin          document.getElementById("timestamp_btc").innerHTML = jsonRet.bitcoin.timestamp;          document.getElementById("market_btc").innerHTML = jsonRet.bitcoin.market;          document.getElementById("bid_btc").innerHTML = jsonRet.bitcoin.bid;          document.getElementById("ask_btc").innerHTML = jsonRet.bitcoin.ask;          document.getElementById("last_price_btc").innerHTML = jsonRet.bitcoin.last_price;          document.getElementById("low_btc").innerHTML = jsonRet.bitcoin.low;          document.getElementById("high_btc").innerHTML = jsonRet.bitcoin.high;          document.getElementById("volume_btc").innerHTML = jsonRet.bitcoin.volume;          //para Ethereum          document.getElementById("timestamp_eth").innerHTML = jsonRet.ethereum.timestamp;          document.getElementById("market_eth").innerHTML = jsonRet.ethereum.market;          document.getElementById("bid_eth").innerHTML = jsonRet.ethereum.bid;          document.getElementById("ask_eth").innerHTML = jsonRet.ethereum.ask;          document.getElementById("last_price_eth").innerHTML = jsonRet.ethereum.last_price;          document.getElementById("low_eth").innerHTML = jsonRet.ethereum.low;          document.getElementById("high_eth").innerHTML = jsonRet.ethereum.high;          document.getElementById("volume_eth").innerHTML = jsonRet.ethereum.volume;        }                console.log(JSON.stringify(metricas));        setColorFondo(jsonRet.bitcoin.criterio, "tituloBTC");        setColorFondo(jsonRet.ethereum.criterio, "tituloETH");      }      function setColorFondo(accion, titulo){        switch(accion){            case "comprar":              document.getElementById(titulo).style.backgroundColor = VERDE;              break;            case "vender":              document.getElementById(titulo).style.backgroundColor = ROJO;              break;            default:              document.getElementById(titulo).style.backgroundColor = GRIS;          }      }      function selectEstrategia(estrategia){        console.log(estrategia.value);        var strategy = estrategia.value;        var estrategia_cripto = strategy.split("-");        metricas[estrategia_cripto[1]] = estrategia_cripto[0];      }  </script></body></html>'.! !!ServidorHTTP methodsFor: 'accessing' stamp: 'AlejandroFerrero 6/6/2021 20:10'!webSocket	^ webSocket! !!ServidorHTTP methodsFor: 'accessing' stamp: 'AlejandroFerrero 6/6/2021 20:10'!nroPuerto	^ nroPuerto! !!ServidorHTTP methodsFor: 'accessing' stamp: 'AlejandroFerrero 6/6/2021 22:00'!html: anObject	html := anObject! !!ServidorHTTP methodsFor: 'accessing' stamp: 'AlejandroFerrero 6/6/2021 20:10'!nroPuerto: anObject	nroPuerto := anObject! !!ServidorHTTP methodsFor: 'accessing' stamp: 'AlejandroFerrero 6/6/2021 20:10'!ipAddr: anObject	ipAddr := anObject! !!ServidorHTTP methodsFor: 'accessing' stamp: 'AlejandroFerrero 6/6/2021 22:00'!html	^ html! !!ServidorHTTP methodsFor: 'accessing' stamp: 'AlejandroFerrero 6/6/2021 20:10'!webSocket: anObject	webSocket := anObject! !!ServidorHTTP methodsFor: 'accessing' stamp: 'AlejandroFerrero 6/6/2021 20:10'!ipAddr	^ ipAddr! !!ServidorHTTP methodsFor: 'servidor' stamp: 'AlejandroFerrero 6/10/2021 22:21'!startServidorZnServer stopDefault.(ZnServer defaultOn: nroPuerto)   bindingAddress: ipAddr;  " logToTranscript;"   start.ZnServer default logToTranscript.ZnServer default delegatemap: 'crypto-servers'to: [ :request | ZnResponse ok: (ZnEntity html: self html) ];map: 'ws-crypto-server'to: (ZnWebSocketDelegate map: 'ws-crypto-server' to:webSocket).! !!ServidorHTTP methodsFor: 'servidor' stamp: 'AlejandroFerrero 6/6/2021 21:28'!stopServidor	ZnServer stopDefault.	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ServidorHTTP class	instanceVariableNames: 'uniqueInstance'!!ServidorHTTP class methodsFor: 'accessing' stamp: 'JuanIgnacioFernandez 6/15/2021 19:46'!uniqueInstance     uniqueInstance ifNil: [ uniqueInstance := self new ].     ^ uniqueInstance! !Object subclass: #WebSocketServer	instanceVariableNames: 'data indicadorCVBTC indicadorCVETH datasimple'	classVariableNames: ''	package: 'TP2-CryptoServer'!!WebSocketServer commentStamp: 'AlejandroFerrero 6/4/2021 16:58' prior: 0!Web Socket del lado del servidor.!!WebSocketServer methodsFor: 'initialization' stamp: 'JuanIgnacioFernandez 6/15/2021 17:28'!initialize	"inicializa los datos a enviar a un JSON vacio, y la metrica por defecto es el RSI"	data := '{}'.	self selectRSIBTC.	self selectRSIETH.! !!WebSocketServer methodsFor: 'observer' stamp: 'JuanIgnacioFernandez 6/16/2021 00:05'!update: aData	|RSI dbtc deth criterioBTC criterioETH valores jsonCriptos|	"Actualiza los datos a enviar via web socket"	datasimple :=aData .	deth := aData at: 'ethereum'.	dbtc := aData at: 'bitcoin'.	criterioBTC := self indicadorCVBTC calcularMetrica: dbtc.	dbtc at:'criterio' put:criterioBTC.	criterioETH := self  indicadorCVETH calcularMetrica: deth.	deth at:'criterio' put:criterioETH.	jsonCriptos := NeoJSONWriter toString: aData.	data := jsonCriptos .! !!WebSocketServer methodsFor: 'accessing' stamp: 'JuanIgnacioFernandez 6/15/2021 17:27'!selectMomentumETH	indicadorCVETH := IndicadorMomentum new.! !!WebSocketServer methodsFor: 'accessing' stamp: 'JuanIgnacioFernandez 6/15/2021 17:24'!indicadorCVBTC	^ indicadorCVBTC! !!WebSocketServer methodsFor: 'accessing' stamp: 'JuanIgnacioFernandez 6/16/2021 00:05'!datasimple: anObject	datasimple := anObject! !!WebSocketServer methodsFor: 'accessing' stamp: 'JuanIgnacioFernandez 6/5/2021 18:30'!data	^ data! !!WebSocketServer methodsFor: 'accessing' stamp: 'JuanIgnacioFernandez 6/15/2021 17:24'!indicadorCVETH	^ indicadorCVETH! !!WebSocketServer methodsFor: 'accessing' stamp: 'JuanIgnacioFernandez 6/15/2021 17:26'!selectRSIETH	indicadorCVETH := IndicadorRSI new.! !!WebSocketServer methodsFor: 'accessing' stamp: 'JuanIgnacioFernandez 6/15/2021 17:24'!selectRSIBTC	indicadorCVBTC := IndicadorRSI new.! !!WebSocketServer methodsFor: 'accessing' stamp: 'JuanIgnacioFernandez 6/5/2021 18:16'!data: anObject	data := anObject! !!WebSocketServer methodsFor: 'accessing' stamp: 'JuanIgnacioFernandez 6/16/2021 00:05'!datasimple	^ datasimple! !!WebSocketServer methodsFor: 'accessing' stamp: 'JuanIgnacioFernandez 6/15/2021 17:27'!selectMomentumBTC	indicadorCVBTC := IndicadorMomentum new.! !!WebSocketServer methodsFor: 'servidor' stamp: 'JuanIgnacioFernandez 6/16/2021 00:05'!value: webSocket	"I stream status messages to a WebSocket client, once every second 	until ConnectionClosed or no longer isConnected"	| msj json IBTC IETH|		[ 		webSocket logGeneric: 'Started status streaming'.		[ 			webSocket sendMessage: self data.			"1 second asDelay wait."			"json :=  webSocket readMessage."			json := [ webSocket readMessage ]					on: ConnectionTimedOut    				do: [ nil ].			json ifNotNil: [  				msj := NeoJSONReader fromString: json.				"msj displayStringOn: Transcript."				IBTC := msj at: 'btc'.				IETH := msj at: 'eth'.				IBTC = 'rsi' ifTrue: [ self selectRSIBTC. ]					ifFalse: [ self selectMomentumBTC . ].				IETH = 'rsi' ifTrue: [ self selectRSIETH. ]					ifFalse: [ self selectMomentumETH . ]. 					self update: datasimple.				].			"Transcript flush."			1 second asDelay wait.			webSocket isConnected ] whileTrue ] 		on: ConnectionClosed 		do: [ webSocket logGeneric: 'Ignoring connection close' ].	webSocket logGeneric: 'Stopping status streaming'! !