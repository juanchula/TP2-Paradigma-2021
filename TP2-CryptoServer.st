Object subclass: #Application	instanceVariableNames: ''	classVariableNames: ''	package: 'TP2-CryptoServer'!!Application commentStamp: 'AlejandroFerrero 6/4/2021 17:52' prior: 0!Es la clase main que crea los objetos y lanza la ejecuci√≥n de la aplicaci√≥n.!Object subclass: #ClienteHTTP	instanceVariableNames: 'scheduler cliente_http_eth cliente_http_btc periodo valoresETH valoresBTC eventManager'	classVariableNames: ''	package: 'TP2-CryptoServer'!!ClienteHTTP commentStamp: 'AlejandroFerrero 6/4/2021 15:39' prior: 0!Clase que realiza requests HTTP (metodo GET) de forma peri√≥dica a la API CryptoMkt para obtener las cotizaciones actuales de una criptomoneda. !!ClienteHTTP methodsFor: 'initialization' stamp: 'AlejandroFerrero 6/6/2021 23:03'!initialize	"se crea un scheduler que ejecuta un GET cada X segundos"	scheduler := TaskScheduler new.	"cliente http para los GET de la cripto Etherium"	cliente_http_eth := ZnClient new		url: 'https://api.cryptomkt.com/v1/ticker?market=ETHARS'.			"cliente http para los GET de la cripto Bitcoin"	cliente_http_btc := ZnClient new		url: 'https://api.cryptomkt.com/v1/ticker?market=BTCARS'.			"periodo en el cual se realizan los GET a la API CryptoMkt"	periodo := 1.		"Array que contiene los valores consultados de la cripto Bitcoin"	valoresBTC := OrderedCollection new.		"Array que contiene los valores consultados de la cripto Etherium"	valoresETH := OrderedCollection new.		"Maneja la lista de objetos suscritos a la espera de un evento."	eventManager := GestorDeEventos new.	! !!ClienteHTTP methodsFor: 'accessing' stamp: 'AlejandroFerrero 6/5/2021 14:48'!cliente_http_btc	^ cliente_http_btc! !!ClienteHTTP methodsFor: 'accessing' stamp: 'AlejandroFerrero 6/4/2021 16:27'!cliente_http_eth: anObject	cliente_http_eth := anObject! !!ClienteHTTP methodsFor: 'accessing' stamp: 'AlejandroFerrero 6/5/2021 15:20'!valoresBTC	^ valoresBTC! !!ClienteHTTP methodsFor: 'accessing' stamp: 'AlejandroFerrero 6/4/2021 16:27'!scheduler: anObject	scheduler := anObject! !!ClienteHTTP methodsFor: 'accessing' stamp: 'AlejandroFerrero 6/4/2021 16:27'!periodo	^ periodo! !!ClienteHTTP methodsFor: 'accessing' stamp: 'AlejandroFerrero 6/5/2021 15:20'!valoresETH	^ valoresETH! !!ClienteHTTP methodsFor: 'accessing' stamp: 'AlejandroFerrero 6/5/2021 15:20'!valoresETH: anObject	valoresETH := anObject! !!ClienteHTTP methodsFor: 'accessing' stamp: 'AlejandroFerrero 6/5/2021 16:41'!eventManager: anObject	eventManager := anObject! !!ClienteHTTP methodsFor: 'accessing' stamp: 'AlejandroFerrero 6/4/2021 16:27'!cliente_http_eth	^ cliente_http_eth! !!ClienteHTTP methodsFor: 'accessing' stamp: 'AlejandroFerrero 6/5/2021 14:48'!cliente_http_btc: anObject	cliente_http_btc := anObject! !!ClienteHTTP methodsFor: 'accessing' stamp: 'AlejandroFerrero 6/4/2021 16:27'!periodo: anObject	periodo := anObject! !!ClienteHTTP methodsFor: 'accessing' stamp: 'AlejandroFerrero 6/4/2021 16:27'!scheduler	^ scheduler! !!ClienteHTTP methodsFor: 'accessing' stamp: 'AlejandroFerrero 6/5/2021 15:20'!valoresBTC: anObject	valoresBTC := anObject! !!ClienteHTTP methodsFor: 'accessing' stamp: 'AlejandroFerrero 6/5/2021 16:41'!eventManager	^ eventManager! !!ClienteHTTP methodsFor: 'scheduling' stamp: 'AlejandroFerrero 6/6/2021 22:07'!setFuncionScheduler	"ejecuta una request http cada X seg periodicamente"		scheduler		do: [ | valBTC valETH valores |			valores := OrderedCollection new.			valBTC := self doGetRequest: cliente_http_btc.			valETH := self doGetRequest: cliente_http_eth.			valoresBTC add: valBTC.			valoresETH add: valETH.			valores add: valBTC;					  add: valETH.			eventManager notify: valores.			"eventManager notify: valETH."  ]		every: self periodo seconds. 	"30 seconds for example"! !!ClienteHTTP methodsFor: 'scheduling' stamp: 'AlejandroFerrero 6/4/2021 16:41'!detenerScheduler	self scheduler stop! !!ClienteHTTP methodsFor: 'scheduling' stamp: 'AlejandroFerrero 6/4/2021 16:31'!comenzarScheduler	self scheduler start! !!ClienteHTTP methodsFor: 'api' stamp: 'AlejandroFerrero 6/6/2021 22:24'!doGetRequest: aClientHTTP	| respuesta json json_dict dict json_ret |	"response de la consulta http"	respuesta := aClientHTTP		get;		response.	"string del body de la response"	json := respuesta entity string.	"se convierte el string devuelto en un diccionario con todos los valores de la cripto"	json_dict := NeoJSONReader fromString: json.	dict := json_dict at: 'data' at: 1.	"se convierte otra vez a JSON y se retorna"	json_ret := NeoJSONWriter toString: dict.	^ json_ret! !Object subclass: #GestorDeEventos	instanceVariableNames: 'listeners'	classVariableNames: ''	package: 'TP2-CryptoServer'!!GestorDeEventos commentStamp: 'AlejandroFerrero 6/4/2021 17:55' prior: 0!Tambi√©n llamado EventManager, es el encargado de mantener la lista de suscriptores y de notificarlos cuando haya ocurrido un evento para los que est√©n esperando.!!GestorDeEventos methodsFor: 'initialization' stamp: 'AlejandroFerrero 6/5/2021 16:06'!initialize	"Crea una lista de listeres"	listeners := OrderedCollection new! !!GestorDeEventos methodsFor: 'observer' stamp: 'AlejandroFerrero 6/6/2021 23:10'!notify: aData	"Notifica a todos los objetos que estan suscritos a un evento. aData es el dato enviado (valor de la cotizacian en el momento) a los objetos."	"1 to: listeners size do:[:indice | (listeners at: indice) update: aData]."	listeners do: [ :item | item update: aData ].! !!GestorDeEventos methodsFor: 'observer' stamp: 'AlejandroFerrero 6/5/2021 16:22'!unsubscribe: aListener	"Elimina de la lista de suscritos a un elemento"	| indice |	indice := listeners indexOf: aListener.	indice > 0		ifTrue: [ listeners removeAt: indice ]! !!GestorDeEventos methodsFor: 'observer' stamp: 'AlejandroFerrero 6/5/2021 16:09'!subscribe: aListener	"Agrega un listener a la lista de suscritos"	listeners add: aListener! !Object subclass: #ServidorHTTP	instanceVariableNames: 'ipAddr nroPuerto webSocket html'	classVariableNames: ''	package: 'TP2-CryptoServer'!!ServidorHTTP commentStamp: 'AlejandroFerrero 6/6/2021 20:06' prior: 0!Servidor HTTP que muestra las cotizaciones actualizadas de las criptomonedas. Utiliza un web socket para actualizar los valores dinámicamente.!!ServidorHTTP methodsFor: 'accessing' stamp: 'AlejandroFerrero 6/6/2021 20:10'!ipAddr: anObject	ipAddr := anObject! !!ServidorHTTP methodsFor: 'accessing' stamp: 'AlejandroFerrero 6/6/2021 20:10'!webSocket	^ webSocket! !!ServidorHTTP methodsFor: 'accessing' stamp: 'AlejandroFerrero 6/6/2021 20:10'!webSocket: anObject	webSocket := anObject! !!ServidorHTTP methodsFor: 'accessing' stamp: 'AlejandroFerrero 6/6/2021 20:10'!ipAddr	^ ipAddr! !!ServidorHTTP methodsFor: 'accessing' stamp: 'AlejandroFerrero 6/6/2021 22:00'!html	^ html! !!ServidorHTTP methodsFor: 'accessing' stamp: 'AlejandroFerrero 6/6/2021 20:10'!nroPuerto	^ nroPuerto! !!ServidorHTTP methodsFor: 'accessing' stamp: 'AlejandroFerrero 6/6/2021 20:10'!nroPuerto: anObject	nroPuerto := anObject! !!ServidorHTTP methodsFor: 'accessing' stamp: 'AlejandroFerrero 6/6/2021 22:00'!html: anObject	html := anObject! !!ServidorHTTP methodsFor: 'initialization' stamp: 'AlejandroFerrero 6/6/2021 22:47'!initialize		ipAddr := #[127 0 0 1].		nroPuerto := 1701.		webSocket := WebSocketServer new.		html := '<!!DOCTYPE html><html lang="es"><head>  <meta charset="utf-8"/>  <meta name="description" content="Aquí puedes encontrar las últimas cotizaciones de las criptomonedas más populares del mercado, junto a algunos consejos de compra.">  <title>Cotizaciones Crypto Server</title></head><body>  <h1>Cotizaciones Crypto Server en tiempo real</h1>  <pre id="data"></pre>  <script language="javascript" type="text/javascript">      var wsUri = "ws://" + location.host + "/ws-crypto-server";      var exampleSocket = new WebSocket(wsUri);      exampleSocket.onmessage = function(event) {      console.log(event.data)      var el = document.body.querySelector("#data");      if(el){        el.textContent = event.data;      }              }  </script></body></html>'.! !!ServidorHTTP methodsFor: 'servidor' stamp: 'AlejandroFerrero 6/6/2021 22:02'!startServidorZnServer stopDefault.(ZnServer defaultOn: nroPuerto)   bindingAddress: ipAddr;   logToTranscript;   start.ZnServer default logToTranscript.ZnServer default delegatemap: 'crypto-servers'to: [ :request | ZnResponse ok: (ZnEntity html: self html) ];map: 'ws-crypto-server'to: (ZnWebSocketDelegate map: 'ws-crypto-server' to:webSocket).! !!ServidorHTTP methodsFor: 'servidor' stamp: 'AlejandroFerrero 6/6/2021 21:28'!stopServidor	ZnServer stopDefault.	! !Object subclass: #WebSocketServer	instanceVariableNames: 'data'	classVariableNames: ''	package: 'TP2-CryptoServer'!!WebSocketServer commentStamp: 'AlejandroFerrero 6/4/2021 16:58' prior: 0!Web Socket del lado del servidor.!!WebSocketServer methodsFor: 'accessing' stamp: 'JuanIgnacioFernandez 6/5/2021 18:30'!data	^ data! !!WebSocketServer methodsFor: 'accessing' stamp: 'JuanIgnacioFernandez 6/5/2021 18:16'!data: anObject	data := anObject! !!WebSocketServer methodsFor: 'observer' stamp: 'AlejandroFerrero 6/6/2021 22:44'!update: aData	data := aData asArray.! !!WebSocketServer methodsFor: 'initialization' stamp: 'AlejandroFerrero 6/6/2021 22:00'!initialize		data := 'ESTO ES LO INICIAL'.	! !!WebSocketServer methodsFor: 'servidor' stamp: 'JuanIgnacioFernandez 6/6/2021 17:40'!value: webSocket	"I stream status messages to a WebSocket client, once every second 	until ConnectionClosed or no longer isConnected"		[ 		webSocket logGeneric: 'Started status streaming'.		[ 			webSocket sendMessage: self data.			1 second asDelay wait.			webSocket isConnected ] whileTrue ] 		on: ConnectionClosed 		do: [ webSocket logGeneric: 'Ignoring connection close' ].	webSocket logGeneric: 'Stopping status streaming' ! !!WebSocketServer methodsFor: 'servidor' stamp: 'JuanIgnacioFernandez 6/5/2021 21:02'!handleRequest: request   request uri path = 'crypto-server'      ifFalse: [ ^ ZnResponse notFound: request uri ].   ^ ZnResponse ok: (ZnEntity text: data).   "^ ZnResponse ok: (ZnEntity dictionary: data)"! !